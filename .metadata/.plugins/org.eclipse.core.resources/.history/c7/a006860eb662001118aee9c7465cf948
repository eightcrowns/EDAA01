public class Sudoku {
	private int[][] sudoku; // [y][x], y=rader av kolumner, x=kolumner i rader
	
	/**
	 * Sudokut anges som en matris vid skapandet av sudokuobjektet
	 * @param sudoku matris av heltal som representerar sudokut som ska lösas
	 */
	public Sudoku(int[][] sudoku) {
		this.sudoku = sudoku;
	}
	
	/**
	 * Lös sudokut. Observera att sudokumatrisen som angivits som parameter
	 * till konstruktorn kommer att skrivas över.
	 * @return true om sudokut gick att lösa, false annars
	 */
	public boolean solve() {
		return solve(0, 0);
	}
	
	private boolean solve(int y, int x) {
		if (sudoku[y][x] > 0) { // finns en siffra i (y, x)
			if (check(y, x)) { // om i är giltigt i (y, x)
				if(y == 8 && x == 8 ) { // sista rutan i sudokut
					return true;
				} else // kör solve på nästa ruta
					if (x == 8) {
						if (solve(y+1, 0)) {
							return true;
						}
					} else {
						if (solve(y, x+1)) {
							return true;
						}
					}
			}
			return false;
		} else { // tomt i (y, x)
			if(y == 8 && x == 8 ) { // sista rutan i sudokut
				for (int i = 1; i <= 9; i++) {
					sudoku[y][x] = i; // prova att sätta in i
					if (check(y, x)) { // om i är giltigt i (y, x)
						return true; // sudokut är löst
					}
				}
				return false;
			} else {
				for (int i = 1; i <= 9; i++) {
					sudoku[y][x] = i; // prova att sätta in i
					if (check(y, x)) { // om i är giltigt i (y, x)
						// kör solve på nästa ruta
						if (x == 8) { // sista rutan i raden
							if (solve(y+1, 0)) {
								return true;
							}
						} else {
							if (solve(y, x+1)) {
								return true;
							}
						}
					}
				}
				sudoku[y][x] = 0;
				return false; // felaktig lösning, gå bakåt
			}
		}
	}
	
	/**
	 * Letar efter förekomster av num i aktuell rad
	 * @param row rad att testa
	 * @param num numret att leta efter
	 * @return true om num inte hittades i raden, false annars
	 */
	private boolean checkRow(int row, int num) {
		int index = 0;
		while (index < 9 && num != sudoku[row][index]) {
			index++;
		}
		return index == 9; // inga dubletter
	}
	
	/**
	 * Letar efter förekomster av num i aktuell kolumn
	 * @param num numret att leta efter
	 * @param col kolumn att testa 
	 * @return true om num inte hittades i kolumnen, false annars
	 */
	private boolean checkColumn(int num, int col) {
		int index = 0;
		while (index < 9 && num != sudoku[index][col]) {
			index++;
		}
		return index == 9; // inga dubletter
	}
	
	/**
	 * Letar efter dubletter i aktuell 3x3-region
	 * @param y
	 * @param x
	 * @param num
	 * @return
	 */
	private boolean checkRegion(int y, int x, int num) {
		boolean noDuplicates = true;
		for (int row = (y / 3) * 3; row < (y / 3 + 1) * 3; row++) {
			for (int col = (x / 3) * 3; col < (x / 3 +1) * 3; col++) {
				if (sudoku[row][col] > 0 && num == sudoku[row][col]) {
					noDuplicates = false; // det finns dubletter i regionen som är > 0, dvs ifyllda
				}
			}
		}
		return noDuplicates;
	}
	
	/**
	 * Utför alla tre kontroller på en ruta
	 * @param y
	 * @param x
	 * @return true om rutan är okej, false annars
	 */
	public boolean check(int y, int x) {
		// Plocka tillfälligt ut värdet från aktuell ruta för att inte upptäcka falska dubletter
		int num = sudoku[y][x];
		sudoku[y][x] = 0;
		
		if (checkRow(y, num) && checkColumn(num, x) && checkRegion(y, x, num)) {
			sudoku[y][x] = num;
			return true;
		} else {
			sudoku[y][x] = num;
			return false;
		}
	}
}
